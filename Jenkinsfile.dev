pipeline {
  agent any

  environment {
    NODE_VERSION = '22.14.0'
    DATABASE_URL = credentials('DATABASE_URL')
    NEXT_PUBLIC_API_URL = 'https://api.hearts-and-paws.dev'
    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = credentials('NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY')
    CLERK_SECRET_KEY = credentials('CLERK_SECRET_KEY')
    DEPLOY_DIR = 'E:\\jenkinnodes\\workspace\\Deployment to Dev\\hearts-and-paws'
    APP_NAME = 'Slack-notification-service'
    
    // JIRA configuration
    JIRA_BASE_URL = credentials('JIRA_BASE_URL')
    JIRA_USERNAME = credentials('jira-username')
    JIRA_API_TOKEN = credentials('jira-admin-token')
    
    // Slack configuration
    SLACK_CHANNEL = credentials('SLACK_CHANNEL')
  }

  stages {
    stage('Checkout Code') {
      steps {
        script {
          echo "üì• Pulling latest changes from branch-dev"
          bat """
            cd ${DEPLOY_DIR}
            git reset --hard HEAD
            git pull origin branch-dev || exit /b 1
          """
        }
      }
    }

 stage('Extract JIRA Issue from Commit') {
      steps {
        script {
          // Use double percent for Windows so that git gets a literal "%B".
          def commitMessageOutput = bat(
            script: "cd ${DEPLOY_DIR} && git log -1 --pretty=%%B",
            returnStdout: true
          ).trim();
          
          echo "Raw commit message output: ${commitMessageOutput}"

          // Split into lines and take the last non-empty line as the commit message.
          def commitMessageLines = commitMessageOutput.split(/[\r\n]+/);
          def commitMessage = "";
          for (int i = commitMessageLines.size() - 1; i >= 0; i--) {
            if (commitMessageLines[i].trim()) {
              commitMessage = commitMessageLines[i].trim();
              break;
            }
          }
          
          echo "Latest commit message: ${commitMessage}"

          // Use a regular expression to extract the JIRA ticket key (e.g., "SCRUM-35").
          def matcher = commitMessage =~ /(SCRUM-\d+)/;
          def jiraKey = matcher ? matcher[0][0] : "";
          
          if (jiraKey) {
            echo "Detected JIRA Issue Key: ${jiraKey}";
            // Store the JIRA key in an environment variable for later use.
            env.JIRA_ISSUE_KEY = jiraKey;
          } else {
            echo "No JIRA Issue Key detected in commit message.";
            env.JIRA_ISSUE_KEY = "";
          }
        }
      }
    }

stage('Query JIRA and Notify Slack') {
  when {
    expression { return env.JIRA_ISSUE_KEY && env.JIRA_ISSUE_KEY != "" }
  }
  steps {
    script {
      // ‚Ä¶ curl + readJSON as before ‚Ä¶

      def summary = issue.fields.summary ?: "No summary provided"
      def status  = issue.fields.status?.name ?: "Unknown"

      // Only for Test status do we add the QA-pr reminder
      def extraMessage = ""
      if (status.equalsIgnoreCase("Test")) {
        extraMessage = """
          ‚Ä¢ :microscope: *Tester*, pull the code from `branch-dev` (or your feature branch) and run your tests locally or in your dev environment.
          ‚Ä¢ When your tests pass, create a PR *from* `branch-dev` *into* `branch-QA` for the next stage.
        """
      }

      def slackMessage = """
        *Code Push Notification*
        *Branch:* branch-dev
        *JIRA Task:* ${env.JIRA_ISSUE_KEY}
        *Summary:* ${summary}
        *Status:* ${status}
        ${extraMessage}
      """.stripIndent()

      slackSend(
        channel: "${env.SLACK_CHANNEL}",
        message: slackMessage,
        color: status.equalsIgnoreCase("Test") ? "warning" : "good",
        botUser: true,
        tokenCredentialId: 'slack-webhook'
      )
    }
  }
}


    stage('Set Up Environment') {
      steps {
        script {
          echo "‚öôÔ∏è Creating .env file..."
          bat """
            cd ${DEPLOY_DIR}
            echo DATABASE_URL=${DATABASE_URL} > .env
            echo CLERK_SECRET_KEY=${CLERK_SECRET_KEY} >> .env
            echo NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY} >> .env
            echo NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL} >> .env
            echo "‚úÖ .env file created successfully!"
            type .env
          """
        }
      }
    }

    stage('Install Node.js') {
      steps {
        script {
          echo "üîß Ensuring Node.js ${NODE_VERSION} is installed..."
          bat """
            set NVM_DIR=C:\\Users\\Administrator\\AppData\\Roaming\\nvm
            set NODEJS_HOME=%NVM_DIR%\\v${NODE_VERSION}
            set PATH=%NODEJS_HOME%;%PATH%
            node -v || exit /b 1
            npm -v || exit /b 1
          """
        }
      }
    }

    stage('Install Dependencies') {
      steps {
        script {
          echo "üì¶ Installing dependencies..."
          bat """
            cd ${DEPLOY_DIR}
            npm install --force || exit /b 1
          """
        }
      }
    }

    stage('Generate Prisma Client') {
      steps {
        script {
          echo "üõ†Ô∏è Generating Prisma Client..."
          bat """
            cd ${DEPLOY_DIR}
            npx prisma generate || exit /b 1
          """
        }
      }
    }

    stage('Run Prisma Migrations') {
      steps {
        script {
          echo "üìú Applying Prisma Migrations..."
          bat """
            cd ${DEPLOY_DIR}
            npx prisma migrate deploy || exit /b 1
          """
        }
      }
    }

    stage('Build Next.js') {
      steps {
        script {
          echo "üèóÔ∏è Building Next.js app..."
          // bat """
          //   cd ${DEPLOY_DIR}
          //   npm run build || exit /b 1
          // """
        }
      }
    }

    stage('Start Application') {
      steps {
        script {
          echo "üöÄ Starting Next.js server..."
          bat """
            cd ${DEPLOY_DIR}
            taskkill /F /IM node.exe || echo "No running process found"
            start /B npm start > nextjs.log 2>&1
          """
        }
      }
    }
  }

  post {
    always {
      script {
        withCredentials([
          string(credentialsId: 'SLACK_CHANNEL', variable: 'SLACK_CHANNEL'),
          string(credentialsId: 'slack-webhook', variable: 'SLACK_WEBHOOK')
        ]) {
          def message = currentBuild.result == 'SUCCESS' ?
            "‚úÖ *Deployment Successful!* üéâ\n*Application:* ${APP_NAME}\n*Environment:* DEV" :
            "‚ùå *Deployment Failed!* üö®\n*Application:* ${APP_NAME}\n*Environment:* DEV";
          def color = currentBuild.result == 'SUCCESS' ? "good" : "danger";
          slackSend channel: "${SLACK_CHANNEL}",
                    message: message,
                    color: color,
                    botUser: true,
                    tokenCredentialId: 'slack-webhook';
        }
      }
    }
  }
}
